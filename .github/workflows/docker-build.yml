# Reusable Docker Build Workflow
# Equivalent to docker-build-pipe for Bitbucket
#
# Builds images using docker buildx bake, pushes to Artifactory,
# and uploads build metadata JSON for downstream deploy workflows.

name: Docker Build

on:
  workflow_call:
    inputs:
      bake_file:
        description: 'Path to docker-bake.hcl file'
        type: string
        default: docker-bake.hcl
      bake_target:
        description: 'Bake target(s) to build'
        type: string
        default: default
      image_name:
        description: 'Image name in registry (defaults to repo name)'
        type: string
        default: ''
      platforms:
        description: 'Target platforms (comma-separated)'
        type: string
        default: linux/amd64
      image_namespace:
        description: 'Image namespace in registry'
        type: string
        default: mwlr-private
      push:
        description: 'Push images to registry'
        type: boolean
        default: true
      registry_host:
        description: 'Artifactory hostname'
        type: string
        required: true
      registry_username:
        description: 'Artifactory username'
        type: string
        required: true
      runs_on:
        description: 'Runner to use (ubuntu-latest for GitHub-hosted, tak-k8s-ci for self-hosted K8s)'
        type: string
        default: 'ubuntu-latest'
      buildkit_endpoint:
        description: 'Central BuildKit endpoint for persistent cache (self-hosted K8s only)'
        type: string
        default: 'tcp://buildkit.buildkit.svc.cluster.local:1234'
    secrets:
      ARTIFACTORY_TOKEN:
        required: true
        description: 'Artifactory identity token'
      BAKE_SECRETS:
        required: false
        description: 'Build secrets in docker secret format'
      REGISTRY_CA_CERT:
        required: false
        description: 'CA certificate for registry TLS verification (PEM format)'
    outputs:
      build_id:
        description: 'Build identifier (run_number-sha)'
        value: ${{ jobs.build.outputs.build_id }}
      image_tag:
        description: 'Image tag'
        value: ${{ jobs.build.outputs.image_tag }}
      registry_prefix:
        description: 'Registry prefix for images'
        value: ${{ jobs.build.outputs.registry_prefix }}
      metadata_url:
        description: 'URL to build index JSON'
        value: ${{ jobs.build.outputs.metadata_url }}

jobs:
  build:
    runs-on: ${{ inputs.runs_on }}
    outputs:
      build_id: ${{ steps.vars.outputs.build_id }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
      registry_prefix: ${{ steps.vars.outputs.registry_prefix }}
      metadata_url: ${{ steps.metadata.outputs.metadata_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set build variables
        id: vars
        run: |
          # Build ID matches Bitbucket convention: build_number-commit_sha
          BUILD_ID="${{ github.run_number }}-${GITHUB_SHA}"
          REPO_NAME="${{ github.event.repository.name }}"
          
          # Use custom image_name if provided, otherwise default to repo name
          IMAGE_NAME="${{ inputs.image_name }}"
          if [[ -z "$IMAGE_NAME" ]]; then
            IMAGE_NAME="${REPO_NAME}"
          fi
          
          REGISTRY_PREFIX="${{ inputs.registry_host }}/docker/${{ inputs.image_namespace }}/${IMAGE_NAME}"
          
          echo "build_id=${BUILD_ID}" >> $GITHUB_OUTPUT
          echo "image_tag=${BUILD_ID}" >> $GITHUB_OUTPUT
          echo "registry_prefix=${REGISTRY_PREFIX}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          
          # For bake file interpolation
          echo "REGISTRY_PREFIX=${REGISTRY_PREFIX}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${BUILD_ID}" >> $GITHUB_ENV
          echo "GIT_ORIGIN=${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_ENV
          echo "GIT_REVISION=${GITHUB_SHA}" >> $GITHUB_ENV

      - name: Install registry CA certificate
        id: ca-cert
        env:
          REGISTRY_CA_CERT: ${{ secrets.REGISTRY_CA_CERT }}
          REGISTRY_HOST: ${{ inputs.registry_host }}
        run: |
          if [[ -z "$REGISTRY_CA_CERT" ]]; then
            echo "No CA certificate provided, skipping"
            echo "has_ca_cert=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_ca_cert=true" >> $GITHUB_OUTPUT
          
          # Add CA to system trust store
          echo "$REGISTRY_CA_CERT" | sudo tee /usr/local/share/ca-certificates/registry-ca.crt > /dev/null
          sudo update-ca-certificates
          
          # Add CA to Docker daemon cert store for registry access
          # This is used by docker login and docker pull/push
          sudo mkdir -p "/etc/docker/certs.d/${REGISTRY_HOST}"
          echo "$REGISTRY_CA_CERT" | sudo tee "/etc/docker/certs.d/${REGISTRY_HOST}/ca.crt" > /dev/null
          
          # Store the cert for later injection into BuildKit
          echo "$REGISTRY_CA_CERT" > /tmp/registry-ca.crt
          
          # Restart Docker daemon to pick up new certificates
          sudo systemctl restart docker
          
          # Wait for Docker to be ready
          sleep 5
          docker info > /dev/null 2>&1
          
          # Verify TLS connection works
          echo "Testing TLS connection to ${REGISTRY_HOST}..."
          curl -v --cacert /usr/local/share/ca-certificates/registry-ca.crt "https://${REGISTRY_HOST}/v2/" 2>&1 | head -50 || true
          
          echo "✓ CA certificate installed for ${REGISTRY_HOST}"

      # Try central BuildKit first (self-hosted K8s runners only)
      # This provides persistent layer + image cache for faster builds
      - name: Try central BuildKit
        id: central-buildkit
        if: inputs.runs_on != 'ubuntu-latest'
        continue-on-error: true
        run: |
          ENDPOINT="${{ inputs.buildkit_endpoint }}"
          BUILDER_NAME="central-buildkit"
          
          echo "Trying central BuildKit at ${ENDPOINT}..."
          
          # Clean up any existing builder
          docker buildx rm "${BUILDER_NAME}" 2>/dev/null || true
          
          # Create builder with remote driver
          if ! docker buildx create \
            --name "${BUILDER_NAME}" \
            --driver remote \
            "${ENDPOINT}"; then
            echo "connected=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verify connection
          if docker buildx inspect --bootstrap "${BUILDER_NAME}" >/dev/null 2>&1; then
            docker buildx use "${BUILDER_NAME}"
            echo "connected=true" >> $GITHUB_OUTPUT
            echo "✓ Connected to central BuildKit (persistent cache)"
          else
            docker buildx rm "${BUILDER_NAME}" 2>/dev/null || true
            echo "connected=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # Fall back to docker-container driver if central BuildKit unavailable
      # BuildKit in docker-container driver runs in an isolated container.
      # We set up the builder first, then inject the CA cert into the container.
      - name: Set up Docker Buildx (fallback)
        if: steps.central-buildkit.outcome != 'success'
        id: buildx-setup
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          driver-opts: |
            image=moby/buildkit:buildx-stable-1
            network=host

      # Inject CA cert into BuildKit container's trust store (only for docker-container driver)
      - name: Configure BuildKit CA certificate
        if: steps.ca-cert.outputs.has_ca_cert == 'true' && steps.central-buildkit.outcome != 'success'
        run: |
          # Get the BuildKit container name
          BUILDKIT_CONTAINER=$(docker ps --filter "name=buildx_buildkit" --format "{{.Names}}" | head -1)
          
          if [[ -z "$BUILDKIT_CONTAINER" ]]; then
            echo "ERROR: BuildKit container not found"
            docker ps -a
            exit 1
          fi
          
          echo "Found BuildKit container: ${BUILDKIT_CONTAINER}"
          
          # Append the CA certificate directly to the CA bundle inside the container
          # BuildKit uses Alpine which has certs at /etc/ssl/certs/ca-certificates.crt
          docker cp /tmp/registry-ca.crt "${BUILDKIT_CONTAINER}:/tmp/registry-ca.crt"
          docker exec "$BUILDKIT_CONTAINER" sh -c 'cat /tmp/registry-ca.crt >> /etc/ssl/certs/ca-certificates.crt'
          
          # Restart buildkitd to pick up the new CA bundle
          docker restart "$BUILDKIT_CONTAINER"
          
          # Wait for buildkitd to be ready
          sleep 5
          
          echo "✓ CA certificate configured in BuildKit container"

      - name: Login to Artifactory
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry_host }}
          username: ${{ inputs.registry_username }}
          password: ${{ secrets.ARTIFACTORY_TOKEN }}

      - name: Build and push
        id: bake
        uses: docker/bake-action@v5
        with:
          files: ${{ inputs.bake_file }}
          targets: ${{ inputs.bake_target }}
          push: ${{ inputs.push }}
          provenance: true
          sbom: true
          set: |
            *.platform=${{ inputs.platforms }}
            *.cache-from=type=registry,ref=${{ steps.vars.outputs.registry_prefix }}:cache
        env:
          REGISTRY_PREFIX: ${{ steps.vars.outputs.registry_prefix }}
          IMAGE_TAG: ${{ steps.vars.outputs.image_tag }}

      - name: Parse bake metadata
        id: parse
        run: |
          # Extract metadata from bake output
          BAKE_METADATA='${{ steps.bake.outputs.metadata }}'
          
          # Create index.json matching docker-build-pipe format
          echo "$BAKE_METADATA" | jq '{
            build_id: "${{ steps.vars.outputs.build_id }}",
            git_origin: "${{ github.server_url }}/${{ github.repository }}",
            git_revision: "${{ github.sha }}",
            git_ref: "${{ github.ref }}",
            timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ")),
            outputs: [
              to_entries[] | {
                target: .key,
                digest: .value."containerimage.digest",
                image: (.value."image.name" // "" | split(",") | .[0])
              }
            ]
          }' > build-index.json
          
          echo "Build index:"
          cat build-index.json

      - name: Upload build metadata to Artifactory
        id: metadata
        if: inputs.push
        run: |
          IMAGE_NAME="${{ steps.vars.outputs.image_name }}"
          BUILD_ID="${{ steps.vars.outputs.build_id }}"
          METADATA_PATH="docker-build-metadata/${IMAGE_NAME}/builds/${BUILD_ID}"
          METADATA_URL="https://${{ inputs.registry_host }}/artifactory/${METADATA_PATH}/index.json"
          
          echo "Uploading build metadata to: ${METADATA_URL}"
          
          curl -fsSL \
            -H "Authorization: Bearer ${{ secrets.ARTIFACTORY_TOKEN }}" \
            -H "Content-Type: application/json" \
            -T build-index.json \
            "${METADATA_URL}"
          
          echo "metadata_url=${METADATA_URL}" >> $GITHUB_OUTPUT
          echo "✓ Metadata uploaded successfully"

      - name: Upload build-index as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-index
          path: build-index.json
          retention-days: 90

      - name: Summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build ID | \`${{ steps.vars.outputs.build_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Registry | \`${{ steps.vars.outputs.registry_prefix }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Metadata | [${{ steps.metadata.outputs.metadata_url }}](${{ steps.metadata.outputs.metadata_url }}) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Built Images" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          jq -r '.outputs[] | "- **\(.target)**: `\(.digest)`"' build-index.json >> $GITHUB_STEP_SUMMARY
